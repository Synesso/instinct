#summary Instinct Roadmap
#labels Featured

= Implementation Plan =
  # ~~Build infrastructure~~
    # ~~Code coverage~~
    # Artifacts
  # ~~TeamCity integration~~
  # ~~Implement core annotations (context, specification)~~
  # ~~Implement suite aggregator~~
  # ~~Get example code working~~
  # ~~Figure out mocking implementation to use~~
  # Auto mocking (dummies, stubs & mocks)
    # Mock discovery
    # Dummy creation
    # Stub creation
    # Mock creation
  # Test coverage to 100%
  # Retrofit Assert.assertX() in tests to use Hamcrest style assertions
  # Auto unique field creation (are these just dummies?)
  # Auto fixture/subject creation
  # Add naming conventions to all locators
  # ~~Come up with nomenclature (see terms.txt)~~
  # Verification classes (Hamcrest?)
    # JUnit Assert feature parity
    # Boost's assertThrows
  # Auto discovery of naming conventions at runtime
  # IntelliJ Plugin
  # Ant runner
  # Revisit distribution mechanism, perhaps an all, src, what about dependencies?
  # ~~Add source to distribution Jar~~
  # Produce Javadoc Jar as part of artifacts

= Core Features =

  * ~~Should allow the use of annotation, naming conventions or interfaces (markers) to mark things.~~
  * Built in framework support for nomenclature: mocks, stubs, etc.
  * IntelliJ IDEA plugin.
  * ~~Support for JUnit runners.~~

= Testing =

  * ~~Allow/encourage more than one Context per class file~~
  * Provide UniqueTestUtil functionality, @Unique annotation & naming convention (are these just dummies?)
  * Create a Verify class similar to Assert. This will allow static access to the checks (so that this just becomes a wrapper). Probably use [http://code.google.com/p/hamcrest/ Hamcrest] to do this.
  * ~~Context classes should not need to have a suffix "Context".~~
  * Provide closure style assertThrows checks.

= Mocking =

  * Bundle a mocking library - probably JMock
  * Create automocker - dummies, stubs & mocks
    * Support automocking using an annotation (@Mock) and naming convention
    * Fields for automocking will require annotation or naming convention (& currently hold null value?)
  * Mock role names should be discovered by using the name of the field (in addition to standard JMock method).
  * ~~Possibly allow different mock types - nice, stubs, etc.~~
  * Should allow mocking to be done automatically or manually. Manual mocking should be explicitly allowed.
  * ~~Expose Mocker via static utility, should have the same hooks into the lifecycle (e.g. verification) as auto mocked fields.~~
  * Implementations ideas:
    * Use JMock style DSL. Wrap JMock classes thinly.
    * Perhaps allow plugable mocking implementations?

= Annotations to Create =
  * ~~Use @BehaviourContext annotation to denote context classes.~~
  * Include an @Fixture annotation to support auto creation of fixtures where able to.
    * If fixtures depend on mocks, use the mock types where possible
    * Perhaps have conditions places on the fixtures to denote how they should be created @Fixture(dependencies=AUTO_MOCK,AUTO_UNIQUE)

= Naming Conventions =
  * Unique fields (also want to be able to specify conditions, e.g. positive int, ranges, etc.)
  * Mocked fields (a mock that is verified)
  * Stub fields (just an instance)
  * Fixtures

= Aggregation =
  * ~~Hook into junit style runners for IDE integration~~
  * IntelliJ plugin to run tests individually (look at code from TestNG plugin - http://code.google.com/p/testng-idea/).

= Functionality =
  * ~~Allow "naming conventions" to be added~~ (discover these at runtime to extend functionality).
  * Need some way to discover what methods to run for non-annotated classes. Provide a naming convention to do this.
  * ~~For classes with annotations, may not want to also add in specification methods discovered by naming conventions.~~

= Test Strategy =
  * Determine how to automatically test core code against example code (maybe seperate classloader). This could form a  "compatibility" suite.