#summary Creating expectations in specifications
#labels Tutorial

<[UsersGuide User's Guide]>

*Note. These details are applicable to Instinct 0.1.6 only, currently available in [http://code.google.com/p/instinct/source SVN].*

= Expectations =

Many testing and BDD frameworks provide a means of making assertions about the state of objects under test (the subject), or objects that are returned by the subject, these APIs are typically called assertion APIs. Mocking frameworks allow expectations to be made on mocks, specifying calls that another class is expected to make on the mock. Instinct takes the view that these two kinds of functions are really just different angles on the same thing. Assertion APIs state expectations about an object's state, mocking APIs state expectations about an object's behaviour (these are often called state & interaction testing respectively).

Instinct therefore contains a single API for stating expectations, the expectation API. Instinct uses [http://code.google.com/p/hamcrest/ Hamcrest] for its state expectations and [http://jmock.org/ jMock] for its behaviour expectations.

= State expectations =

Instinct's expectation API has been designed for readability (within the constraints of Java's syntax and type system), flexibility and its usefulness when being used from within an IDE. Expectations should clearly denote the intent of statement and 

Consider the following JUnit assertion:

{{{
void testRunnerSendsSpecifiationResultsToOutput() {
  assertTrue("Expected to find context name",
      runnerOutput.contains(className));
}
}}}

And the corresponding Instinct expectation:

{{{
void sendsSpecifiationResultsToOutput() {
  expect.that(runnerOutput).containsString(className);
}
}}}

Instinct expectations do not need to include strings describing the condition being checked as the expectation itself clearly denotes the intent. Consider the following JUnit  assertions:

{{{
assertEquals(1, map.size());
assertTrue(map.containsKey(1000));
assertEquals(fileNames, map.get(1000));
}}}

These can be re-written as:

{{{
expect.that(map).hasSize(1);
expect.that(map).containsKey(1000);
expect.that(map).containsEntry(1000, fileNames);
}}}

When using the expectation API you not only get better syntax, the process of creating the expectations is much easier. Use of the expectation API has been specifically tailored to guide you down the right path. Instinct uses type-safe checkers to ensure that you can only set expectations for the type of the object you are checking. For example it does makes sense to check the length of an array or a list, but not an integer.


== Checkers ==

TODO: Describe the different kinds of checkers.

== Extending ==

TODO: Describe the extensions available.

  * Inherit from/delegate to the checkers
  * Additional hamcrest matchers
  * Create your own Expect and ExpectThat implementation.

Future versions of Instinct will make it easier to provide your own extensions to 

= Behaviour expectations =

Instinct's mocking is based on [http://www.jmock.org/ jMock], with thin wrappers that make jMock expectations look more like Instinct's state expectations and that simplify (i.e. hide) the lifecycle of jMock `Mock`s and `Mockery`.

As such you can use make use of all of [http://www.jmock.org/cheat-sheet.html jMock's syntax] when writing your specifications:

{{{
class ACsvFileReaderWithNothingToRead {
    @Subject private CsvFileReader csvFileReader;
    @Mock private CsvFile csvFile;
    @Stub(auto = false) private CsvLine[] noLines;

    @BeforeSpecification
    void before() {
        noLines = new CsvLine[]{};
        csvFileReader = new CsvFileReaderImpl(csvFile);
    }

    @Specification
    void returnsNoLines() {
        expect.that(new Expectations() {{
            one(csvFile).hasMoreLines(); will(returnValue(false));
            ignoring(csvFile).close();
        }});
        expect.that(csvFileReader.readLines()).isEqualTo(noLines);
    }
}
}}}

TODO: Discuss:
  * jMock sequences
  * jMock State machines

<[UsersGuide User's Guide]>