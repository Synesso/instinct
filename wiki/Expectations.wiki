#summary Creating expectations in specifications
#labels Tutorial

<[UsersGuide User's Guide]>

*Note. These details are applicable to Instinct 0.1.6 only, currently available in [http://code.google.com/p/instinct/source SVN].*

= Expectations =

Many testing and BDD frameworks provide a means of making assertions about the state of objects under test (the subject), or objects that are returned by the subject, these APIs are typically called assertion APIs. Mocking frameworks allow expectations to be made on mocks, specifying calls that another class is expected to make on the mock. Instinct takes the view that these two kinds of functions are really just different angles on the same thing. Assertion APIs state expectations about an object's state, mocking APIs state expectations about an object's behaviour (these are often called state & interaction testing respectively).

Instinct therefore contains a single API for stating expectations, the expectation API. Instinct uses [http://code.google.com/p/hamcrest/ Hamcrest] for its state expectations and [http://jmock.org/ jMock] for its behaviour expectations.

= State expectations =

TODO: Note the EDSL nature of the expectations.
TODO: Note use of static import. You are meant to statically import it.

Instinct's expectation API has been designed for readability (within the constraints of Java's syntax and type system), flexibility and its usefulness when being used from within an IDE. 

Expectations should clearly denote the intent of the code they are specifying. Consider the following JUnit assertion:

{{{
void testRunnerSendsSpecifiationResultsToOutput() {
  assertTrue("Expected to find context name", runnerOutput.contains(className));
}
}}}

And the corresponding Instinct expectation:

{{{
void sendsSpecifiationResultsToOutput() {
  expect.that(runnerOutput).containsString(className);
}
}}}

The Instinct expectation clearly denotes the intent of the statement. Because of this, Instinct expectations do not need to include strings describing the condition being checked, as the expectation itself clearly denotes the intent. Consider the following JUnit  assertions:

{{{
assertEquals(1, map.size());
assertTrue(map.containsKey(1000));
assertEquals(fileName, map.get(1000));
}}}

These can be re-written as:

{{{
expect.that(map).hasSize(1);
expect.that(map).containsKey(1000);
expect.that(map).containsEntry(1000, fileName);
}}}

When using the expectation API you not only get better syntax, the process of creating the expectations is much easier. Use of the expectation API has been specifically tailored to guide you down the right path as you're typing the expectation.

It does this by using type-safe checkers to ensure that you can only set expectations for the type of the object you are checking. For example it does makes sense to check the length of an array or a list, but not an integer.

Instinct exploits the completion ability of Java IDEs to provide the correct checkers based on the subject of the expectation. For example consider the following subject:

{{{
interface FileChunkHolder {
    Map<Integer, String> getFileNamesByChunk();
}
}}}

Here's a specification that describes the expected behaviour.

{{{
...
}}}



{{{
expect.that(map).hasSize(1);

expect.that(map).containsEntry(1000, fileName);

}}}

The type-safety of the checkers not only...

== Checkers ==

Instinct uses [http://code.google.com/p/hamcrest/ Hamcrest] to perform state-based expectation checking (as does JUnit 4.4 & jMock). Instinct provides a thin wrapper around  Hamcrest matchers to integrate them into the common expectation API and to provide type-safe matchers. For example it will only show you the matchers that are appropriate to the type you are checking. Instinct also uses this wrapping to provide more readable method names. For example the `IsEqual.equalTo()` matcher is used in Hamcrest as `assertThat(foo, equalTo(bar))`, whereas in Instinct it reads more naturally as `expect.that(foo).isEqualTo(bar)`.

TODO: Describe the different kinds of checkers, include examples of each.

Checkers
  * ArrayChecker
  * BooleanChecker
  * ClassChecker
  * CollectionChecker
  * ComparableChecker
  * DoubleChecker
  * EventObjectChecker
  * FileChecker
  * IterableChecker
  * MapChecker
  * NodeChecker
  * ObjectChecker
  * StringChecker

== Extending ==

TODO: Describe the extensions mechanisms available.

  * Inherit from/delegate to the checkers
  * Additional hamcrest matchers
  * Create your own Expect and ExpectThat implementation.


However there are downsides to using the inbuilt in Instinct state-based checkers

Denote the downsides of using the checkers, it's not easy to write your own, they become second class citizens of the framework.

Future versions of Instinct will make it easier to provide your own extensions to 

= Behaviour expectations =

Instinct's mocking is based on [http://www.jmock.org/ jMock], with thin wrappers that make jMock expectations look more like Instinct's state expectations and that simplify (i.e. hide) the lifecycle of jMock `Mock`s and `Mockery`.

As such you can use make use of all of [http://www.jmock.org/cheat-sheet.html jMock's syntax] when writing your specifications:

{{{
class ACsvFileReaderWithNothingToRead {
    @Subject private CsvFileReader csvFileReader;
    @Mock private CsvFile csvFile;
    @Stub(auto = false) private CsvLine[] noLines;

    @BeforeSpecification
    void before() {
        noLines = new CsvLine[]{};
        csvFileReader = new CsvFileReaderImpl(csvFile);
    }

    @Specification
    void returnsNoLines() {
        expect.that(new Expectations() {{
            one(csvFile).hasMoreLines(); will(returnValue(false));
            ignoring(csvFile).close();
        }});
        expect.that(csvFileReader.readLines()).isEqualTo(noLines);
    }
}
}}}

TODO: Discuss:
  * jMock sequences
  * jMock State machines

<[UsersGuide User's Guide]>